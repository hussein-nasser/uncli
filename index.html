<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UN Logs</title>
</head>
<body>

    <table border =0>
        <tr>
            <td>
            Admin User
        </td>
            <td colspan =5><input type = 'text' id = 'txtAdmin' value = 'admin'></td>
        </tr>
        <tr>
        <td>
            Admin Password
        </td>
            <td colspan =5><input type = 'password' id = 'txtPassword' value = ''></td>
        </tr>
        <tr>
            
            <td colspan =6><button id = 'btnLogin'>Login</button></td>
            </tr>
        <tr><td>Service</td>
            <td colspan =5 ><select id ='cmbService'>
                
            </select>
            </td>
        </tr>
         
    <tr> 
        <td >Age</td>
        <td colspan =5><input type ='text' id = 'txtAge' value = '10' style="width:30px"> minutes</td>
    </tr>
    <tr>
        <td>Message</td>
        <td><input id = 'txtFilter' type = 'text'></td>
        <td>User</td>
        <td colspan =3><input id = 'txtUser' type = 'text'></td>
    </tr>
    <tr>

        <td title = "Newer date goes here">Start Time</td>
        <td><input id = 'txtStartTime' type = 'text'></td>
        <td title = "Older date goes here">End Time</td>
        <td colspan =3><input id = 'txtEndTime' type = 'text'></td>
    </tr>
    <tr>

        <td>Method Name</td>
        <td><input id = 'txtMethodName' type = 'text'></td>
        <td>RequestID</td>
        <td colspan =3><input id = 'txtRequestId' type = 'text'></td>
    </tr>
</table>

<table> 
    <tr>
        <td colspan = 9>
            <button id = 'btnTraceLogs'>Trace Logs</button> 
            <button id = 'btnValidateLogs'>Validate Logs</button> 
            <button id = 'btnUpdateSubnetworkLogs'>Update Subnetwork Logs</button>
            <button id = 'btnAR'>Attribute Rules Logs</button> 
            <button id = 'btnSQLLogs'>SQL Logs</button>
            <button id = 'btnApplyEditsLogs'>ApplyEdits Logs</button>
            <button id = 'btnQueryLogs'>Query Logs</button>
            <button id = 'btnReconcileLogs'>Reconcile Logs</button>
            <button id = 'btnstopEditingLogs'>StopEditing Logs</button>
            <button id = 'btnDownloadLogs'>Raw Logs</button>
        </td>
        
    </tr>
    <tr><td colspan=9><small>Elapsed time is in minutes:seconds:milliseconds</small></td></tr>
    </table>

    <table id = 'tblResult' border =1 cellpadding = 4 cellspacing = 4 style="text-align:left">

    </table>
    <script type = 'module'>
        import { Portal } from "./portal.mjs"
        import { UtilityNetwork } from "./utilitynetwork.node.mjs"
        import { AdminLog } from "./adminlog.mjs"
        import  logger  from "./logger.mjs"
 
     
 
    let parameters = {
        "user": "",
        "password": "",
        "portal": "",  //https://utilitynetwork.esri.com/portal set your portal url webadaptor if not /portal
        "service": "",
        "referer": "", //set the referer to be the same url you are running this from https://utilitynetwork.esri.com/log,
        "server": undefined //when there are multiple federate server, update the correct one here.  
    
    }

    if (parameters.portal === "") parameters.portal = window.location.origin + "/portal"
    if (parameters.referer === "") parameters.referer = window.location.href

    let portal;
    let adminLog = null;
    let cmbService 
   let token;
    const btnLogin = document.getElementById("btnLogin")
    const txtAdmin = document.getElementById("txtAdmin");
    const txtPassword = document.getElementById("txtPassword")

    btnLogin.addEventListener("click", () => init())

    function msToMinSecMs(millis) {
        const minutes = Math.floor(millis / 60000);
        const seconds = Math.floor(((millis % 60000) / 1000))
        const miliseconds =Math.floor( ((millis % 60000) % 1000)  )
        return minutes + ":" + (seconds < 10 ? '0' : '') + seconds + "." +  (miliseconds < 10 ? '00' : '') + (miliseconds >= 10 && miliseconds <=99 ? '0' : '') + miliseconds
}

    async function init() {
        try {


        parameters.user =   txtAdmin.value;
        parameters.password = txtPassword.value;
        parameters.referer = window.location.href;
           
        cmbService = document.getElementById("cmbService")
        while (cmbService.firstChild) cmbService.removeChild(cmbService.firstChild)
         
        token = await getToken(parameters);

        //if we logged in successfully 
        let opt = document.createElement("option")
        opt.textContent = "(All Services)"
        cmbService.appendChild (opt)

        opt = document.createElement("option")
        opt.textContent = "System/ValidationTools.GPServer"
        cmbService.appendChild (opt)

         opt = document.createElement("option")
        opt.textContent = "System/UtilityNetworkTools.GPServer"
        cmbService.appendChild (opt)

         opt = document.createElement("option")
        opt.textContent = "System/VersionManagementTools.GPServer"
        cmbService.appendChild (opt)


        const services = await portal.services()
        const featureServices = services.services.filter(s => s.type == "FeatureServer")
        featureServices.forEach(s=> {
            const o = document.createElement("option");
            o.text = s.name;
            cmbService.appendChild(o);
        })
        

        
        document.getElementById("btnTraceLogs").disabled = false 
        document.getElementById("btnValidateLogs").disabled = false 
        document.getElementById("btnUpdateSubnetworkLogs").disabled = false 
        document.getElementById("btnAR").disabled = false 
        document.getElementById("btnSQLLogs").disabled = false 
        document.getElementById("btnApplyEditsLogs").disabled = false 
        document.getElementById("btnQueryLogs").disabled = false 
        document.getElementById("btnDownloadLogs").disabled = false 
        document.getElementById("btnReconcileLogs").disabled = false 
        document.getElementById("btnstopEditingLogs").disabled = false 
        

        }
        catch(ex){
            alert(`Failed to login to ${parameters.portal} check the user/password and make sure its an admin: \n\nMore details: ${JSON.stringify(ex)}`)
        }
    }


    async function getToken(parameters) {
        portal = new Portal(parameters.portal, parameters.user, parameters.password,30000, parameters.server, parameters.referer)
        console.log("About to connect..")
        const token = await portal.connect()
        console.log(`Token generanted successfully.`)
        return token;
    }


    async function loadTraceLogs () {
   
        //build table
        const tblResult = document.getElementById("tblResult");
        //clear
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)


        parameters.service = cmbService.options[cmbService.selectedIndex].text
    
        let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes
 
        console.log(`Querying trace logs for ${parameters.service} for the last ${mins} minutes ...`)
            
         //page query the admin log
       let allTheMessages = await adminLogQueryWithPaging(mins, parameters.service, [102002], "------ Trace Parameters ----", "VERBOSE")
            
       let allMessages = filterMessages (allTheMessages).map(m => {
            const newMessage = Object.assign({}, m);
            delete newMessage.machine;
            delete newMessage.type;
            delete newMessage.code;
            //delete newMessage.requestID;
            delete newMessage.process;
            delete newMessage.thread;
            newMessage.elapsedms = parseInt (parseFloat(newMessage.elapsed) * 1000)
            newMessage.time = new Date(newMessage.time).toLocaleString()
            delete newMessage.elapsed

            try{
                
                //Total Trace Time (4.745 seconds)
    
                let re = /Total Trace Time \([-+]?([0-9]*\.[0-9]+|[0-9]+) seconds\)/;
                let res = re.exec(m.message)
                if (res && res.length  > 1)
                    newMessage.traceTime = parseFloat(res[1])*1000
        
                let re1 = /Trace Type: .\w.*/;
                let res1 = re1.exec(m.message)
                if (res1 && res1.length  > 0)
                    newMessage.traceType = res1[0].replace("Trace Type: ","")

  
                let x ;
                x = /Version name:.*,/.exec(m.message);
                if (x && x.length > 0) newMessage.versionName = x[0].replace("Version name:", "").replace(",", "")

                x = /Moment:.*\r\n/.exec(m.message);
                if (x && x.length > 0) newMessage.moment = x[0].replace("Moment:", "").replace("\r\n", "") * 1000000
   
 
            }
            catch(ex){
               console.error(ex)
            }
 

            return newMessage;
        })
        .sort( (m1,m2) => m2.elapsedms - m1.elapsedms)
        
        //clear
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)

        const header = document.createElement("tr");
        const cService = document.createElement("th");
        cService.textContent = "Source"
        const cTime = document.createElement("th");
        cTime.textContent = "Time"
        const cUser = document.createElement("th");
        cUser.textContent = "User"
        const cMethod = document.createElement("th");
        cMethod.textContent = "Method"
        const cVersion = document.createElement("th");
        cVersion.textContent = "Version"
        const cMoment = document.createElement("th");
        cMoment.textContent = "Moment"
        const cElapsedMS = document.createElement("th");
        cElapsedMS.textContent = "Elapsed"
        const cTraceType = document.createElement("th");
        cTraceType.textContent = "Trace Type"
        const cTraceTime = document.createElement("th");
        cTraceTime.textContent = "Trace Time"
        const cRequestId = document.createElement("th");
        cRequestId.textContent = "RequestId"
        const cLog = document.createElement("th");
        cLog.textContent = "Full Log"
        header.appendChild (cService)
        header.appendChild (cTime)
        header.appendChild (cUser)
        header.appendChild (cMethod)
        header.appendChild (cVersion)
        header.appendChild (cMoment)
        header.appendChild (cTraceType)
        header.appendChild (cTraceTime)
        header.appendChild (cRequestId)
        header.appendChild (cElapsedMS)

        header.appendChild (cLog) 
        tblResult.appendChild(header)
        allMessages.forEach(m => {
            const logRow = document.createElement("tr");
            const cService = document.createElement("td");
            cService.textContent = m.source.replace(".MapServer", "")
            const cTime = document.createElement("td");
            cTime.textContent = m.time
            const cUser = document.createElement("td");
            cUser.textContent = m.user
            const cMethod = document.createElement("td");
            cMethod.textContent = m.methodName
            const cElapsedMS = document.createElement("td");
            cElapsedMS.textContent = msToMinSecMs(m.elapsedms)
            const cTraceType = document.createElement("td");
            cTraceType.textContent = m.traceType
            const cTraceTime = document.createElement("td");
            cTraceTime.textContent = msToMinSecMs(m.traceTime)
            const cRequestId = document.createElement("td");
            cRequestId.textContent = m.requestID
            const cVersion = document.createElement("td");
            cVersion.textContent = m.versionName 
            const cMoment = document.createElement("td");
            cMoment.textContent = m.moment
            const cLog = document.createElement("td");
            cLog.textContent = "..."
            cLog.fullLog = m.message;
            cLog.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.fullLog); alert("Copied to clipboard")})
            logRow.appendChild (cService)
            logRow.appendChild (cTime)
            logRow.appendChild (cUser)
            logRow.appendChild (cMethod)
            logRow.appendChild (cVersion)
            logRow.appendChild (cMoment)
            logRow.appendChild (cTraceType)
            logRow.appendChild (cTraceTime)
            logRow.appendChild (cRequestId)
            logRow.appendChild (cElapsedMS)

            logRow.appendChild (cLog) 
            tblResult.appendChild(logRow)
        })


        addCSV(allMessages) 
         //await populateMessages(allMessages)
 
         
    }
 

    
    async function loadValidateLogs () {
        //build table
        const tblResult = document.getElementById("tblResult");
       
    parameters.service = cmbService.options[cmbService.selectedIndex].text

        
  let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes

  console.log(`Querying validate logs for ${parameters.service} for the last ${mins} minutes ...`)
    
  
    let allMessages = [];     
            //clear
            while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
             
            
            //-1 && m.message.indexOf("The network is built.") > -1 && m.methodName == 'BuildEngineLog')
            //page query the admin log
            // prior to 11.1 let allMessages = await adminLogQueryWithPaging(mins, parameters.service, [102003], "The network is built.", "VERBOSE")
            let allMessagesNew = await adminLogQueryWithPaging(mins, parameters.service, [102003,100002], "", "DEBUG")
            
            allMessagesNew = allMessagesNew.filter(m => 	m.message.indexOf( "String request successfully processed.") >= 0  ||  m.message.indexOf( "End ValidateNetworkTopology") >= 0 || m.message.indexOf( "Network built.") >= 0 )
 
            //Network built:
            //validate logs missing elapsed populate it
            allMessagesNew = allMessagesNew.map( m => {
                try{
                    
                    //The network is built. 0.093 seconds (4.982 total) - 29 MB memory
                    //Network built:  0.056 seconds (0.359 total) - 0 MB memory   
                //let re = /The network is built. [-+]?([0-9]*\.[0-9]+|[0-9]+) seconds \([-+]?([0-9]*\.[0-9]+|[0-9]+) total\)/;
                
                
                //get extent
                
                let x ;
                x = /Extent:.*\r\n/.exec(m.message);
                if (x && x.length > 0) m.extent = x[0].replace("Extent:", "").replace("\r\n", "")
                x = /Version name:.*\r\n/.exec(m.message);
                if (x && x.length > 0) m.versionName = x[0].replace("Version name:", "").replace("\r\n", "")

                let re = new RegExp(`Network built. [-+]?([0-9]*\\.[0-9]+|[0-9]+) seconds \\([-+]?([0-9]*\\.[0-9]+|[0-9]+) total\\)`)
                let res = re.exec(m.message)
                
                if (!res)
                {
                        //try with th other string
                     re = new RegExp(`Network built:  [-+]?([0-9]*\\.[0-9]+|[0-9]+) seconds \\([-+]?([0-9]*\\.[0-9]+|[0-9]+) total\\)`)
                     res = re.exec(m.message)
                }
                if (res && res.length  > 1)
                    m.validateTime = res[2]
                    
                    return m;
                }
                

                catch(ex){
                    return m;
                }


            })

            //build out the dictionary, key is request id, value is another dictionary
            const queryLogs = {}
            //sort by time
            allMessages = allMessagesNew.sort ( (m1, m2) => m2.time - m1.time )
            allMessages.forEach (m => {

                if (!queryLogs[m.requestID])
                    queryLogs[m.requestID] = {"message": "Time,Method,Elapsed_ms,Message"}

                queryLogs[m.requestID].message += "\r\n" + m.time + "," + m.methodName + "," + Math.round(m.elapsed*1000) + "," + m.message 

                //get elapsed
                //check for async (method GPReconcileVersionAsync::Execute)
                //sync
                //VersionManagementServer::HandleREST_ReconcileOperation
                //message Returned moment: 
                if (m.message.indexOf("End ValidateNetworkTopology")> -1 || m.message.indexOf("String request successfully processed.") > -1 )
                /*
                ( m.methodName.indexOf("UtilityNetworkServer::HandleREST_ValidateNetworkTopologyOperation") > -1 ||
                m.methodName.indexOf("GPServer.ExecuteJob.ValidateNetworkTopology") > -1 
                ) 
                */
                
                {
                    queryLogs[m.requestID].elapsed = m.elapsed
                    queryLogs[m.requestID].source = m.source.replace(".MapServer", "")
                    queryLogs[m.requestID].user = m.user
                    queryLogs[m.requestID].time = m.time
                    queryLogs[m.requestID].requestID = m.requestID
                    queryLogs[m.requestID].methodName = m.methodName

                    
                }


                if(m.validateTime) {
                    queryLogs[m.requestID].validateTime = m.validateTime
                    queryLogs[m.requestID].versionName = m.versionName
                    queryLogs[m.requestID].extent = m.extent
                }
                 

                
                
            })

            allMessages = []

            Object.keys(queryLogs).forEach(k =>
                {
                    const m = queryLogs[k]
                    if (m.validateTime && m.elapsed)
                        allMessages.push(m)
                    
                }) 
         

          //  allMessages.push(...allMessagesNew);

  


     //sort messages
                
    allMessages = filterMessages (allMessages).map(m => {
            const newMessage = Object.assign({}, m);
            delete newMessage.machine;
            delete newMessage.type;
            delete newMessage.code;
            //delete newMessage.requestID;
            delete newMessage.process;
            delete newMessage.thread;
            newMessage.validateTime = parseInt (parseFloat(newMessage.validateTime) * 1000)
            newMessage.elapsedms = parseInt (parseFloat(newMessage.elapsed) * 1000)
            newMessage.time = new Date(newMessage.time).toLocaleString()
            delete newMessage.elapsed
            return newMessage;
        })
        .sort( (m1,m2) => m2.elapsedms - m1.elapsedms)
         
        //clear
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)

        const header = document.createElement("tr");
        const cService = document.createElement("th");
        cService.textContent = "Source"
        const cTime = document.createElement("th");
        cTime.textContent = "Time"
        const cUser = document.createElement("th");
        cUser.textContent = "User"
        const cMethod = document.createElement("th");
        cMethod.textContent = "Method"
        const cExtent = document.createElement("th");
        cExtent.textContent = "Extent"
        const cVersion = document.createElement("th");
        cVersion.textContent = "Version"

        const cValidateTime = document.createElement("th");
        cValidateTime.textContent = "Validate Time "

        const cElapsedMS = document.createElement("th");
        cElapsedMS.textContent = "Elapsed "

        const cRequestId = document.createElement("th");
        cRequestId.textContent = "RequestId"
        const cLog = document.createElement("th");
        cLog.textContent = "Full Log"

        header.appendChild (cService)
        header.appendChild (cTime)
        header.appendChild (cUser)
        header.appendChild (cMethod)
        header.appendChild (cExtent)
        header.appendChild (cVersion)
        header.appendChild (cValidateTime)
        header.appendChild (cElapsedMS)
        header.appendChild (cRequestId)
        header.appendChild (cLog) 
        tblResult.appendChild(header)
        allMessages.forEach(m => {
            const logRow = document.createElement("tr");
            const cService = document.createElement("td");
            cService.textContent = m.source.replace(".MapServer", "")
            const cTime = document.createElement("td");
            cTime.textContent = m.time
            const cUser = document.createElement("td");
            cUser.textContent = m.user
            const cMethod = document.createElement("td");
            cMethod.textContent = m.methodName
            const cExtent = document.createElement("td");
            cExtent.textContent = m.extent
            const cVersion = document.createElement("td");
            cVersion.textContent = m.versionName

            const cValidateTime = document.createElement("td");
            cValidateTime.textContent = msToMinSecMs(m.validateTime)
            
            const cElapsedMS = document.createElement("td");
            cElapsedMS.textContent = msToMinSecMs(m.elapsedms)

            const cRequestId = document.createElement("td");
            cRequestId.textContent = m.requestID;
            const cLog = document.createElement("td");
            cLog.textContent = "..."
            cLog.fullLog = m.message;
            cLog.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.fullLog); alert("Copied to clipboard")})
            logRow.appendChild (cService)
            logRow.appendChild (cTime)
            logRow.appendChild (cUser)
            logRow.appendChild (cMethod)
            logRow.appendChild (cExtent)
            logRow.appendChild (cVersion)
            logRow.appendChild (cValidateTime)
            logRow.appendChild (cElapsedMS)
            logRow.appendChild (cRequestId)
            logRow.appendChild (cLog) 
            tblResult.appendChild(logRow)
        })

   //await populateMessages(allMessages)
   addCSV(allMessages) 
   
}


async function loadUpdateSubnetworkLogs () {
        //build table
        const tblResult = document.getElementById("tblResult");
        //clear
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
 
        parameters.service = cmbService.options[cmbService.selectedIndex].text 
        
        
        let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes

        
        console.log(`Querying subnetwork logs for ${parameters.service} for the last ${mins} minutes ...`)
        let allTheMessages = await adminLogQueryWithPaging(mins, parameters.service, [102003], "---- Subnetwork Parameters ----", "VERBOSE")

          
        
       let allMessages = filterMessages (allTheMessages).map(m => {
           
        const newMessage = Object.assign({}, m);
        try{
          
            delete newMessage.machine;
            delete newMessage.type;
            delete newMessage.code;
            //delete newMessage.requestID;
            delete newMessage.process;
            delete newMessage.thread;
         
                
                let re = /Total \([-+]?([0-9]*\.[0-9]+|[0-9]+) seconds\)/;
                let res = re.exec(m.message)
                if (res && res.length  > 0)
                    newMessage.elapsed = res[1]

                re = /Total update subnetwork time \([-+]?([0-9]*\.[0-9]+|[0-9]+) seconds\)/;
                res = re.exec(m.message)
                if (res && res.length  > 0)
                    newMessage.elapsed = res[1]
 
                    
                let re1 = /Subnetwork name: .*/;
                let res1 = re1.exec(m.message)
                if (res1 && res1.length  > 0)
                    newMessage.subnetworkName = res1[0].replace("Subnetwork name: ","")
                    
         
                newMessage.elapsedms = parseInt (parseFloat(newMessage.elapsed) * 1000)
                newMessage.time = new Date(newMessage.time).toLocaleString()
                delete newMessage.elapsed
                
  
            }
            catch(ex){
                console.error(ex)
            }
            finally {
                return newMessage;
            }

        })
        .sort( (m1,m2) => m2.elapsedms - m1.elapsedms)
        
        //clear
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)

        const header = document.createElement("tr");
        const cService = document.createElement("th");
        cService.textContent = "Source"
        const cTime = document.createElement("th");
        cTime.textContent = "Time"
        const cUser = document.createElement("th");
        cUser.textContent = "User"
        const cMethod = document.createElement("th");
        cMethod.textContent = "Method"
        const cElapsedMS = document.createElement("th");
        cElapsedMS.textContent = "Elapsed "
        const cSubnetworkName = document.createElement("th");
        cSubnetworkName.textContent = "Subnetwork Name"
        const cRequestId = document.createElement("th");
        cRequestId.textContent = "RequestId"
        const cLog = document.createElement("th");
        cLog.textContent = "Full Log"
        header.appendChild (cService)
        header.appendChild (cTime)
        header.appendChild (cUser)
        header.appendChild (cMethod)
        header.appendChild (cSubnetworkName)
        header.appendChild (cElapsedMS)
        header.appendChild (cRequestId) 
        header.appendChild (cLog) 
        tblResult.appendChild(header)
        allMessages.forEach(m => {
            const logRow = document.createElement("tr");
            const cService = document.createElement("td");
            cService.textContent = m.source.replace(".MapServer", "")
            const cTime = document.createElement("td");
            cTime.textContent = m.time
            const cUser = document.createElement("td");
            cUser.textContent = m.user
            const cMethod = document.createElement("td");
            cMethod.textContent = m.methodName
            const cElapsedMS = document.createElement("td");
            cElapsedMS.textContent =msToMinSecMs(m.elapsedms)
            const cSubnetworkName = document.createElement("td");
            cSubnetworkName.textContent = m.subnetworkName
            const cRequestId = document.createElement("td");
            cRequestId.textContent = m.requestID
            const cLog = document.createElement("td");
            cLog.textContent = "..."
            cLog.fullLog = m.message;
            cLog.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.fullLog); alert("Copied to clipboard")})
            logRow.appendChild (cService)
            logRow.appendChild (cTime)
            logRow.appendChild (cUser)
            logRow.appendChild (cMethod)
            logRow.appendChild (cSubnetworkName)
            logRow.appendChild (cElapsedMS)
            logRow.appendChild (cRequestId)
            logRow.appendChild (cLog) 
            tblResult.appendChild(logRow)
        })

    addCSV(allMessages) 
  
   
}



async function loadAttributeRules () {
    
        //build table
        const tblResult = document.getElementById("tblResult");
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
 
        let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes

        parameters.service = cmbService.options[cmbService.selectedIndex].text 
     
        let showMaxGuid = true
        let showMinGuid = false 
             
        logger.info(`Querying attribute rules logs for ${parameters.service} in the past ${mins} minutes...`)
        let allMessages = await adminLogQueryWithPaging(mins, parameters.service, [102003], "Attribute rule executed:", "DEBUG")

 
        const arMessages = filterMessages(allMessages)
            .filter(m => m.message.indexOf("Attribute rule executed: ") > -1)
            .map (m =>  JSON.parse(m.message.replace("Attribute rule executed: ", "")))
            .map( m => {
                m["Elapsed Time (ms)"] =  Math.round(m["Elapsed Time"]*1000000)/1000
               // m["Arcade Evaluation Time:"] = Math.round(m["Arcade Evaluation Time:"]*1000,6)
                //m.ArcadeTime = m["Arcade Evaluation Time:"]
                
                delete  m["Arcade Evaluation Time:"];
                delete  m["Elapsed Time"];
                //delete m ['GlobalID'];
                return m
            })
            .sort( (m1, m2) => m2["Elapsed Time (ms)"]- m1["Elapsed Time (ms)"])
            .reduce( ( prev, cur ) => {
                if (prev [cur["Rule name"]] === undefined)
                   { 
                       prev [cur["Rule name"]] =  {
                           "totalTime": 0,
                           "occurrence": 0,
                           "minTime":  Number.MAX_SAFE_INTEGER,
                           "maxTime": -1,
                           "avgTime": 0,
                           "maxGuid": null,
                           "minGuid": null
                       };
                     }
                
                     prev [cur["Rule name"]].totalTime = prev [cur["Rule name"]].totalTime + cur["Elapsed Time (ms)"]
                      
                     if (cur["Elapsed Time (ms)"] < prev [cur["Rule name"]].minTime ) {
                        prev [cur["Rule name"]].minTime = cur["Elapsed Time (ms)"];
                        prev [cur["Rule name"]].minGuid = cur["GlobalID"];
                     }

                    if (cur["Elapsed Time (ms)"] > prev [cur["Rule name"]].maxTime ){
                        prev [cur["Rule name"]].maxTime = cur["Elapsed Time (ms)"];
                        prev [cur["Rule name"]].maxGuid = cur["GlobalID"];
                    }
                     
                    prev [cur["Rule name"]].occurrence++
                     
                    prev [cur["Rule name"]].avgTime = prev [cur["Rule name"]].totalTime / prev [cur["Rule name"]].occurrence

                return prev
            }, {})

        const rules = Object.keys(arMessages)
        .map(a => {
                const rule = {}
                rule["Attribute Rule"] = a;
                rule["Total Cost (ms)"] = parseFloat(arMessages[a].totalTime.toFixed(2))
                rule["Occurrence"] = parseFloat(arMessages[a].occurrence)
                if (!showMinGuid && !showMaxGuid) rule["Average Cost (ms)"] = parseFloat(arMessages[a].avgTime.toFixed(2))
                rule["Max execution time (ms)"] = parseFloat(arMessages[a].maxTime.toFixed(2))
                if (showMaxGuid) rule["Max GUID"] = arMessages[a].maxGuid
                rule["Min execution time (ms)"] = parseFloat(arMessages[a].minTime.toFixed(2))
                if (showMinGuid) rule["Min GUID"] = arMessages[a].minGuid
                if (!showMinGuid && !showMaxGuid) rule["Occurrence"] = arMessages[a].occurrence;
                return rule;
        })
        .sort( (m1, m2) => m2["Total Cost (ms)"] -m1["Total Cost (ms)"])
        console.table(rules)

        /*
        Attribute Rule                        
        │ Total Cost (ms) 
        │ Max execution time (ms) 
        │ Max GUID 
        │ Min execution time (m

        */
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)

        const header = document.createElement("tr");
        const cAttributeRule = document.createElement("th");
        cAttributeRule.textContent = "Attribute Rule"
      
        const cTotalCost = document.createElement("th");
        cTotalCost.textContent = "Total Cost (ms)"
      
        const cOccurrence = document.createElement("th");
        cOccurrence.textContent = "Occurrence"

        const cMaxExecutionTime = document.createElement("th");
        cMaxExecutionTime.textContent = "Max execution time (ms)"

        const cMaxGuid = document.createElement("th");
        cMaxGuid.textContent = "Max GUID"

        const cMinExecutionTime = document.createElement("th");
        cMinExecutionTime.textContent = "Min execution time (ms)"

 
        header.appendChild (cAttributeRule)
        header.appendChild (cTotalCost)
        header.appendChild (cOccurrence)
        header.appendChild (cMaxExecutionTime)
        header.appendChild (cMaxGuid)
        header.appendChild (cMinExecutionTime)
    
        tblResult.appendChild(header)


        rules.forEach(rule => 
            {
             
                const logRow = document.createElement("tr");
                const cAttributeRule = document.createElement("td");
                cAttributeRule.textContent = rule["Attribute Rule"]
            
                const cOccurrence = document.createElement("td");
                cOccurrence.textContent = rule["Occurrence"]
             
                const cTotalCost = document.createElement("td");
                cTotalCost.textContent = msToMinSecMs(rule["Total Cost (ms)"])

                const cMaxExecutionTime = document.createElement("td");
                cMaxExecutionTime.textContent = msToMinSecMs(rule["Max execution time (ms)"])

                const cMaxGuid = document.createElement("td");
                cMaxGuid.textContent = rule["Max GUID"] 

                const cMinExecutionTime = document.createElement("td");
                cMinExecutionTime.textContent =  msToMinSecMs(rule["Min execution time (ms)"])
                
                logRow.appendChild (cAttributeRule)
                logRow.appendChild (cTotalCost)
                logRow.appendChild (cOccurrence)
                logRow.appendChild (cMaxExecutionTime)
                logRow.appendChild (cMaxGuid)
                logRow.appendChild (cMinExecutionTime)
                tblResult.appendChild(logRow)
                
 
        })


        const totalARExecution = rules.reduce( (prev, cur) =>  prev + cur["Total Cost (ms)"], 0)
        console.log(`Total time spend executing attribute rules (${Math.round(totalARExecution)} ms) (${Math.round(totalARExecution/1000)} s) (${Math.round(totalARExecution/(1000*60))} m)`)
        addCSV(rules) 


}


async function downloadLogs () {

    //build table
    const tblResult = document.getElementById("tblResult");
    //clear
    while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
        

    parameters.service = cmbService.options[cmbService.selectedIndex].text
    
    
    let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes

  
    console.log(`Querying all debug logs for ${parameters.service} for the last ${mins} minutes ...`)

        //startTime is the most recent
        //endTime is the oldest

         
     //page query the admin log
     let allMessages = await adminLogQueryWithPaging(mins, parameters.service, [], "", "DEBUG")
 
     //filter make time pretty
     allMessages = filterMessages (allMessages)
     .sort( (m1,m2) => m2.time - m1.time)
     .map(m => {
            const newMessage = Object.assign({}, m);
            newMessage.time = new Date(newMessage.time).toLocaleString()
            newMessage.elapsed = Math.round(newMessage.elapsed * 1000) ;
            return newMessage;
        })
      

     await populateMessagesAsIs(allMessages)
     addCSV(allMessages)
 
}

function addCSV (allMessages) {
    
  allMessages = filterMessages (allMessages).map(m => {
            const newMessage = Object.assign({}, m);
            newMessage.message = newMessage?.message?.replace(",","-")
            newMessage.message = newMessage?.message?.replace("\"","-")
            return newMessage;
        })

    const csv=  jsonToCSV(allMessages)
    const blob = new Blob([csv], {"type": "text/csv"});
    const url = window.URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.download    = "log.csv";
    a.href        = url;
    a.textContent = "Download log.csv";
    tblResult.appendChild(a);

}

  function jsonToCSV(jsonObj) {
 
var fields = Object.keys(jsonObj[0])
var replacer = function(key, value) { return value === null ? '' : value } 
var csv = jsonObj.map(function(row){
  return fields.map(function(fieldName){
    return JSON.stringify(row[fieldName], replacer)
  }).join(',')
})
csv.unshift(fields.join(',')) // add header column
 csv = csv.join('\r\n');
 return csv;
}


async function loadApplyEditsLogs () {

//build table
const tblResult = document.getElementById("tblResult");
//clear
while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
    

parameters.service = cmbService.options[cmbService.selectedIndex].text


let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes


console.log(`Querying applyEdits logs for ${parameters.service} for the last ${mins} minutes ...`)

    //startTime is the most recent
    //endTime is the oldest

     
 //page query the admin log , search for /applyEdits logs by methodname
  let allMessages = await adminLogQueryWithPaging(mins, parameters.service, [17002,100004], "", "FINE", "/applyEdits")


  while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)

    let i =0;
    
    const header = document.createElement("tr");
    const cService = document.createElement("th");
    cService.textContent = "Source"
    const cTime = document.createElement("th");
    cTime.textContent = "Time"
    const cUser = document.createElement("th");
    cUser.textContent = "User"
    const cVersion = document.createElement("th");
    cVersion.textContent = "Version"
    const cIds = document.createElement("th");
    cIds.textContent = "LayerIds"
    const cTotalTime = document.createElement("th");
    cTotalTime.title  = "Total time applyEdits took"
    cTotalTime.textContent = "Total Time"
    const cRequestId = document.createElement("th");
    cRequestId.textContent = "RequestId"
    const cLog = document.createElement("th");
    cLog.textContent = "applyEdits payload"
    header.appendChild (cService)
    header.appendChild (cTime)
    header.appendChild (cUser)
    header.appendChild (cVersion)
    header.appendChild (cIds)
    header.appendChild (cTotalTime)
    header.appendChild (cRequestId) 
    header.appendChild (cLog) 
    tblResult.appendChild(header)

    //build out the dictionary, key is request id, value is another dictionary
    const applyEditslogs = {}
    
    allMessages.forEach (m => {

        if (!applyEditslogs[m.requestID])
            applyEditslogs[m.requestID] = {}
        //get elapsed
        if (m.message.indexOf("REST request successfully processed. Response size is ") > -1)
        {
            applyEditslogs[m.requestID].elapsed = m.elapsed
            applyEditslogs[m.requestID].source = m.source.replace(".MapServer", "")
            applyEditslogs[m.requestID].user = m.user
            applyEditslogs[m.requestID].time = m.time
            applyEditslogs[m.requestID].requestID = m.requestID

        }
        
        if (m.message.indexOf("GraphicFeatureServer::HandleRESTRequest ## inputJSON ") > -1)
        {
            applyEditslogs[m.requestID].message = m.message.replace("GraphicFeatureServer::HandleRESTRequest ## inputJSON = ","")
            const applyEditsPayload = JSON.parse(applyEditslogs[m.requestID].message)
            applyEditslogs[m.requestID].gdbVersion = applyEditsPayload.gdbVersion
            applyEditslogs[m.requestID].ids =  [...new Set(applyEditsPayload.edits.reduce ( (prev, cur) => {prev.push(cur.id); return prev}, []) )]; 
        }

        
        
    })

    allMessages = []

     Object.keys(applyEditslogs).forEach(k =>
        {
            const m = applyEditslogs[k]
            allMessages.push(m)
              
        })


    
  console.log ("Filtering messages...") 
 
  allMessages = filterMessages(allMessages)
  .sort( (m1,m2) => Math.round(m2.elapsed*1000) -Math.round(m1.elapsed*1000))

  allMessages.forEach (m => {  
            const logRow = document.createElement("tr");
  
            const cService = document.createElement("th");
            cService.textContent = m.source

            const cTime = document.createElement("td");
            cTime.textContent =  new Date(m.time).toLocaleString()

            const cUser = document.createElement("td");
            cUser.textContent = m.user

            const cVersion = document.createElement("td");
            cVersion.textContent = m.gdbVersion 
           
            
            const cIds = document.createElement("td");
            cIds.textContent = m.ids 

            const cTotalTime = document.createElement("td");
            cTotalTime.textContent = msToMinSecMs(m.elapsed*1000 )  
             
            const cRequestId = document.createElement("td");
            cRequestId.textContent = m.requestID

            const cLog = document.createElement("td");
            const cLogText = document.createElement("input")
            cLogText.type = "text"
            cLogText.style = "width:400px"
            cLogText.value =  m.message
            cLogText.readOnly= true;
            cLog.appendChild(cLogText)
            //cLog.fullLog = m.payLoad;
            //cLog.title = m.payLoad + "\nClick to copy"
           // cLog.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.fullLog); e.target.selectionStart = 0; e.target.selectionEnd = e.target.value.length;
            //    alert("Copied to clipboard")  })
            logRow.appendChild (cService)
            logRow.appendChild (cTime)
            logRow.appendChild (cUser)
            logRow.appendChild (cVersion)
            logRow.appendChild (cIds)
            logRow.appendChild (cTotalTime)
            logRow.appendChild (cRequestId) 
            logRow.appendChild (cLog) 
            tblResult.appendChild(logRow)
  });
  
    addCSV(allMessages)

}




async function stopEditingLogs () {

//build table
const tblResult = document.getElementById("tblResult");
//clear
while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
    

parameters.service = cmbService.options[cmbService.selectedIndex].text


let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes


console.log(`Querying stop editing logs for ${parameters.service} for the last ${mins} minutes ...`)

    //startTime is the most recent
    //endTime is the oldest

     
 //page query the admin log , search for /stopediting logs by methodname
  let allMessages = await adminLogQueryWithPaging(mins, parameters.service, [102003,17003], "", "DEBUG")


  while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)

    let i =0;
    
    const header = document.createElement("tr");
    const cService = document.createElement("th");
    cService.textContent = "Source"
    const cTime = document.createElement("th");
    cTime.textContent = "Time"
    const cUser = document.createElement("th");
    cUser.textContent = "User"
    const cVersion = document.createElement("th");
    cVersion.textContent = "Version"
    const cMethodName = document.createElement("th");
    cMethodName.textContent = "MethodName"
    const cRequestId = document.createElement("th");
    cRequestId.textContent = "RequestId"
    const cTotalTime = document.createElement("th");
    cTotalTime.title  = "Total time stopEditing took"
    cTotalTime.textContent = "Total Time"
 

    const cLog = document.createElement("th");
    cLog.textContent = "StopEditing details"
    header.appendChild (cService)
    header.appendChild (cTime)
    header.appendChild (cUser)
    header.appendChild (cVersion)
    header.appendChild (cMethodName)
    header.appendChild (cRequestId)
    header.appendChild (cTotalTime)
 
    header.appendChild (cLog) 
    tblResult.appendChild(header)

    //build out the dictionary, key is request id, value is another dictionary
    const queryLogs = {}
    //sort by time
    allMessages = allMessages.sort ( (m1, m2) => m2.time - m1.time )
    allMessages.forEach (m => {

        if (!queryLogs[m.requestID])
            queryLogs[m.requestID] = {"message": "Time,Method,Elapsed_ms,Message"}

        queryLogs[m.requestID].message += "\r\n" + m.time + "," + m.methodName + "," + Math.round(m.elapsed*1000) + "," + m.message 

        //get elapsed
        //check for async (method GPReconcileVersionAsync::Execute)
        //sync
        //VersionManagementServer::HandleREST_ReconcileOperation
        //message Returned moment: 
        if  ( m.methodName.indexOf("VersionManagementServer::HandleREST_StopEditingOperation") > -1  
           && m.message.indexOf("End StopEditing") > -1
        )
        {
            queryLogs[m.requestID].elapsed = m.elapsed
            queryLogs[m.requestID].source = m.source.replace(".MapServer", "")
            queryLogs[m.requestID].user = m.user
            queryLogs[m.requestID].time = m.time
            queryLogs[m.requestID].requestID = m.requestID
            queryLogs[m.requestID].methodName = m.methodName.replace("VersionManagementServer::HandleREST_","")
 
        }
        
        if (m.message.indexOf("In WorkspaceInfo::GetVersionedWorkspaceInfo : Cache hit for versionOrBranchName=") > -1)
        {   
            let v =  m.message.replace(": In WorkspaceInfo::GetVersionedWorkspaceInfo : Cache hit for versionOrBranchName=","")
            v = v.substr(v.indexOf("{"))
            queryLogs[m.requestID].gdbVersion =v
    
        }

        
        
    })

    allMessages = []

     Object.keys(queryLogs).forEach(k =>
        {
            const m = queryLogs[k]
            if (m.methodName)
                allMessages.push(m)
              
        })


    
  console.log ("Filtering messages...") 
 
  allMessages = filterMessages(allMessages)
  .sort( (m1,m2) => Math.round(m2.elapsed*1000) -Math.round(m1.elapsed*1000))

  allMessages.forEach (m => {  
            const logRow = document.createElement("tr");
  
            const cService = document.createElement("th");
            cService.textContent = m.source

            const cTime = document.createElement("td");
            cTime.textContent =  new Date(m.time).toLocaleString()

            const cUser = document.createElement("td");
            cUser.textContent = m.user

            const cVersion = document.createElement("td");
            cVersion.textContent = m.gdbVersion 
           
            const cMethodName = document.createElement("td");
            cMethodName.textContent = m.methodName         

            const cRequestId = document.createElement("td");
            cRequestId.textContent = m.requestID 
  
            const cTotalTime = document.createElement("td");
            cTotalTime.textContent =  msToMinSecMs(m.elapsed*1000 )
            const cLog = document.createElement("td");
            cLog.textContent = "..."
            cLog.title = "Click to copy full stopediting log"
            cLog.fullLog = m.message;
            cLog.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.fullLog); alert("Copied to clipboard")})
        
            //cLog.fullLog = m.payLoad;
            //cLog.title = m.payLoad + "\nClick to copy"
           // cLog.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.fullLog); e.target.selectionStart = 0; e.target.selectionEnd = e.target.value.length;
            //    alert("Copied to clipboard")  })
            logRow.appendChild (cService)
            logRow.appendChild (cTime)
            logRow.appendChild (cUser)
            logRow.appendChild (cVersion)
            logRow.appendChild (cMethodName)
            logRow.appendChild (cRequestId)
            logRow.appendChild (cTotalTime)
 
            logRow.appendChild (cLog) 
            tblResult.appendChild(logRow)
  });
  
    addCSV(allMessages)



}



async function reconcileLogs () {

//build table
const tblResult = document.getElementById("tblResult");
//clear
while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
    

parameters.service = cmbService.options[cmbService.selectedIndex].text


let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes


console.log(`Querying reconcile logs for ${parameters.service} for the last ${mins} minutes ...`)

    //startTime is the most recent
    //endTime is the oldest

     
 //page query the admin log , search for /applyEdits logs by methodname
  let allMessages = await adminLogQueryWithPaging(mins, parameters.service, [102003,102024,102023], "", "DEBUG")


  while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)

    let i =0;
    
    const header = document.createElement("tr");
    const cService = document.createElement("th");
    cService.textContent = "Source"
    const cTime = document.createElement("th");
    cTime.textContent = "Time"
    const cUser = document.createElement("th");
    cUser.textContent = "User"
    const cVersion = document.createElement("th");
    cVersion.textContent = "Version"
    const cMethodName = document.createElement("th");
    cMethodName.textContent = "MethodName"
    const cRequestId = document.createElement("th");
    cRequestId.textContent = "RequestId"
    const cTotalTime = document.createElement("th");
    cTotalTime.title  = "Total time reconcile took"
    cTotalTime.textContent = "Total Time"
 

    const cLog = document.createElement("th");
    cLog.textContent = "Reconcile details"
    header.appendChild (cService)
    header.appendChild (cTime)
    header.appendChild (cUser)
    header.appendChild (cVersion)
    header.appendChild (cMethodName)
    header.appendChild (cRequestId)
    header.appendChild (cTotalTime)
 
    header.appendChild (cLog) 
    tblResult.appendChild(header)

    //build out the dictionary, key is request id, value is another dictionary
    const queryLogs = {}
    //sort by time
    allMessages = allMessages.sort ( (m1, m2) => m2.time - m1.time )
    allMessages.forEach (m => {

        if (!queryLogs[m.requestID])
            queryLogs[m.requestID] = {"message": "Time,Method,Elapsed_ms,Message"}

        queryLogs[m.requestID].message += "\r\n" + m.time + "," + m.methodName + "," + Math.round(m.elapsed*1000) + "," + m.message 

        //get elapsed
        //check for async (method GPReconcileVersionAsync::Execute)
        //sync
        //VersionManagementServer::HandleREST_ReconcileOperation
        //message Returned moment: 
        if (m.message.indexOf("Returned moment: ")> -1 && 
        ( m.methodName.indexOf("VersionManagementServer::HandleREST_ReconcileOperation") > -1 ||
         m.methodName.indexOf("GPReconcileVersionAsync::Execute") > -1 
        ) 
        )
        {
            queryLogs[m.requestID].elapsed = m.elapsed
            queryLogs[m.requestID].source = m.source.replace(".MapServer", "")
            queryLogs[m.requestID].user = m.user
            queryLogs[m.requestID].time = m.time
            queryLogs[m.requestID].requestID = m.requestID
            queryLogs[m.requestID].methodName = m.methodName
 
        }
        
        if (m.message.indexOf("EndReconcile;") > -1)
        {
            queryLogs[m.requestID].gdbVersion = m.message.replace("EndReconcile;","")
   
            
        }

        
        
    })

    allMessages = []

     Object.keys(queryLogs).forEach(k =>
        {
            const m = queryLogs[k]
            if (m.methodName)
                allMessages.push(m)
              
        })


    
  console.log ("Filtering messages...") 
 
  allMessages = filterMessages(allMessages)
  .sort( (m1,m2) => Math.round(m2.elapsed*1000) -Math.round(m1.elapsed*1000))

  allMessages.forEach (m => {  
            const logRow = document.createElement("tr");
  
            const cService = document.createElement("th");
            cService.textContent = m.source

            const cTime = document.createElement("td");
            cTime.textContent =  new Date(m.time).toLocaleString()

            const cUser = document.createElement("td");
            cUser.textContent = m.user

            const cVersion = document.createElement("td");
            cVersion.textContent = m.gdbVersion 
           
            const cMethodName = document.createElement("td");
            cMethodName.textContent = m.methodName         

            const cRequestId = document.createElement("td");
            cRequestId.textContent = m.requestID 
  
            const cTotalTime = document.createElement("td");
            cTotalTime.textContent =  msToMinSecMs(m.elapsed*1000 )
            const cLog = document.createElement("td");
            cLog.textContent = "..."
            cLog.title = "Click to copy full reconcile log"
            cLog.fullLog = m.message;
            cLog.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.fullLog); alert("Copied to clipboard")})
        
            //cLog.fullLog = m.payLoad;
            //cLog.title = m.payLoad + "\nClick to copy"
           // cLog.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.fullLog); e.target.selectionStart = 0; e.target.selectionEnd = e.target.value.length;
            //    alert("Copied to clipboard")  })
            logRow.appendChild (cService)
            logRow.appendChild (cTime)
            logRow.appendChild (cUser)
            logRow.appendChild (cVersion)
            logRow.appendChild (cMethodName)
            logRow.appendChild (cRequestId)
            logRow.appendChild (cTotalTime)
 
            logRow.appendChild (cLog) 
            tblResult.appendChild(logRow)
  });
  
    addCSV(allMessages)



}


async function loadQueryLogs () {

//build table
const tblResult = document.getElementById("tblResult");
//clear
while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
    

parameters.service = cmbService.options[cmbService.selectedIndex].text


let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes


console.log(`Querying query logs for ${parameters.service} for the last ${mins} minutes ...`)

    //startTime is the most recent
    //endTime is the oldest

     
 //page query the admin log , search for /applyEdits logs by methodname
  let allMessages = await adminLogQueryWithPaging(mins, parameters.service, [17002,100004], "", "FINE", "layers/")


  while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)

    let i =0;
    
    const header = document.createElement("tr");
    const cService = document.createElement("th");
    cService.textContent = "Source"
    const cTime = document.createElement("th");
    cTime.textContent = "Time"
    const cUser = document.createElement("th");
    cUser.textContent = "User"
    const cVersion = document.createElement("th");
    cVersion.textContent = "Version"
    const cMoment = document.createElement("th");
    cMoment.textContent = "Moment"
    const cMethodName = document.createElement("th");
    cMethodName.textContent = "MethodName"
    const cTotalTime = document.createElement("th");
    cTotalTime.title  = "Total time query took"
    cTotalTime.textContent = "Total Time"

    const cWhere = document.createElement("th");
    cWhere.textContent = "Where clause"
    const cGeometry = document.createElement("th");
    cGeometry.textContent = "Geometry/Extent"

    const cRequestId = document.createElement("th");
    cRequestId.textContent = "RequestId"

    const cLog = document.createElement("th");
    cLog.textContent = "query payload"
    header.appendChild (cService)
    header.appendChild (cTime)
    header.appendChild (cUser)
    header.appendChild (cVersion)
    header.appendChild (cMoment)
    header.appendChild (cMethodName)
    header.appendChild (cTotalTime)

    header.appendChild (cWhere)
    header.appendChild (cGeometry)
    header.appendChild (cRequestId)
    header.appendChild (cLog) 
    tblResult.appendChild(header)

    //build out the dictionary, key is request id, value is another dictionary
    const queryLogs = {}
    
    allMessages.forEach (m => {

        if (!queryLogs[m.requestID])
            queryLogs[m.requestID] = {}
        //get elapsed
        if (m.message.indexOf("REST request successfully processed. Response size is ") > -1)
        {
            queryLogs[m.requestID].elapsed = m.elapsed
            queryLogs[m.requestID].source = m.source.replace(".MapServer", "")
            queryLogs[m.requestID].user = m.user
            queryLogs[m.requestID].time = m.time
            queryLogs[m.requestID].requestID = m.requestID

        }
        
        if (m.message.indexOf("GraphicFeatureServer::HandleRESTRequest ## inputJSON = ") > -1)
        {
            queryLogs[m.requestID].message = m.message.replace("GraphicFeatureServer::HandleRESTRequest ## inputJSON = ","")
            const queryPayload = JSON.parse(queryLogs[m.requestID].message)
            queryLogs[m.requestID].gdbVersion = queryPayload.gdbVersion
            queryLogs[m.requestID].moment = queryPayload.historicMoment
            queryLogs[m.requestID].methodName = m.methodName;
            queryLogs[m.requestID].where = queryPayload.where
            queryLogs[m.requestID].geometry = JSON.stringify(queryPayload.geometry)
            
        }

        
        
    })

    allMessages = []

     Object.keys(queryLogs).forEach(k =>
        {
            const m = queryLogs[k]
            allMessages.push(m)
              
        })


    
  console.log ("Filtering messages...") 
 
  allMessages = filterMessages(allMessages)
  .sort( (m1,m2) => Math.round(m2.elapsed*1000) -Math.round(m1.elapsed*1000))

  allMessages.forEach (m => {  
            const logRow = document.createElement("tr");
  
            const cService = document.createElement("th");
            cService.textContent = m.source

            const cTime = document.createElement("td");
            cTime.textContent =  new Date(m.time).toLocaleString()

            const cUser = document.createElement("td");
            cUser.textContent = m.user

            const cVersion = document.createElement("td");
            cVersion.textContent = m.gdbVersion 
           
            const cMoment = document.createElement("td");
            cMoment.textContent = m.moment 
           
            const cMethodName = document.createElement("td");
            cMethodName.textContent = m.methodName 

            const cWhere = document.createElement("td");
            cWhere.textContent = m.where 

            const cGeometry = document.createElement("td");
            cGeometry.textContent = m.geometry

            
            const cRequestId = document.createElement("td");
            cRequestId.textContent = m.requestID

            const buildGeoPython = `
def make_poly(array):
    json = dict(hasZ=False, hasM=False, rings=array)
    return arcpy.AsShape(json, esri_json=True)

g = ${m.geometry}
if 'rings' in g:
    arcpy.CopyFeatures_management(make_poly(g['rings']), 'memory/foo')
else:
    verts = [[[g['xmin'], g['ymin']], [g['xmin'], g['ymax']], [g['xmax'
             ], g['ymax']], [g['xmax'], g['ymin']]]]
    arcpy.CopyFeatures_management(make_poly(verts), 'memory/foo')

            `
            cGeometry.pythonCode = buildGeoPython
               //cLog.fullLog = m.payLoad;
            cGeometry.title =  "\nClick to copy python code to generate geometry"
            cGeometry.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.pythonCode); alert("Copied to clipboard")})

            const cTotalTime = document.createElement("td");
            cTotalTime.textContent = msToMinSecMs(m.elapsed*1000 )  
            const cLog = document.createElement("td");
            const cLogText = document.createElement("input")
            cLogText.type = "text"
            cLogText.style = "width:400px"
            cLogText.value =  m.message
            cLogText.readOnly= true;
            cLog.appendChild(cLogText)
         
            logRow.appendChild (cService)
            logRow.appendChild (cTime)
            logRow.appendChild (cUser)
            logRow.appendChild (cVersion)
            logRow.appendChild (cMoment)
            logRow.appendChild (cMethodName)
            logRow.appendChild (cTotalTime)
            logRow.appendChild (cWhere)
            logRow.appendChild (cGeometry)
            logRow.appendChild (cRequestId)
            logRow.appendChild (cLog) 
            tblResult.appendChild(logRow)
  });
  
    addCSV(allMessages)

}


async function loadSQLLogs () {

    //build table
    const tblResult = document.getElementById("tblResult");
    //clear
    while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
        

    parameters.service = cmbService.options[cmbService.selectedIndex].text
    
    
    let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes

  
    console.log(`Querying cursor sql logs for ${parameters.service} for the last ${mins} minutes ...`)

        //startTime is the most recent
        //endTime is the oldest

         
     //page query the admin log
      let allMessages = await adminLogQueryWithPaging(mins, parameters.service, [102023], "EndCursor;", "DEBUG")


      console.log ("Filtering messages...")
      
      allMessages = filterMessages(allMessages)
            .map( m=> {
                m.dataAccessElapsed =0;
                m.executeQueryElapsed = 0;
                const sDataAccess = "DataAccess "
                const idxDataAccess = m.message.indexOf(sDataAccess)
                if (idxDataAccess >=0) {
                    const idxNext = m.message.indexOf(" ",idxDataAccess + sDataAccess.length )
                    m.dataAccessElapsed = parseInt(m.message.substr( idxDataAccess + sDataAccess.length, idxNext - idxDataAccess - sDataAccess.length))
                }

                const sExecuteQuery = "ExecuteQuery "
                const idxExecuteQuery = m.message.indexOf(sExecuteQuery)
                if (idxExecuteQuery >=0) {
                    const idxNext = m.message.indexOf(" ",idxExecuteQuery + sExecuteQuery.length)
                    m.executeQueryElapsed = parseInt(m.message.substr( idxExecuteQuery + sExecuteQuery.length, idxNext - idxExecuteQuery - sExecuteQuery.length))
                }
                

                //m.dataAccessElapsed = parseFloat(m.message.split(";")[1].split(" ")[1])
               //m.executeQueryElapsed = parseFloat(m.message.split(";")[2].split(" ")[1])
                m.totalExecutionElapsed = m.dataAccessElapsed +  m.executeQueryElapsed 
                m.elapsed = parseFloat(m.elapsed); return m;

            })
            .sort( (m1,m2) => m2.totalExecutionElapsed - m1.totalExecutionElapsed)
            .slice(0, 100) ;//first 100
    
     
        console.log("-----Top SQL----")
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)

        let i =0;
        
        const header = document.createElement("tr");
        const cService = document.createElement("th");
        cService.textContent = "Source"
        const cTime = document.createElement("th");
        cTime.textContent = "Time"
        const cUser = document.createElement("th");
        cUser.textContent = "User"
        const cVersion = document.createElement("th");
        cVersion.textContent = "Version"
        const cQueryTime = document.createElement("th");
        cQueryTime.textContent = "Query Time"
        cQueryTime.title  = "includes search + data access nextRow"
        const cTotalTime = document.createElement("th");
        cTotalTime.title  = "Total time the cursor was opened"
        cTotalTime.textContent = "Total Time"

        const cRequestId = document.createElement("th");
        cRequestId.textContent = "RequestId"

        const cLog = document.createElement("th");
        cLog.textContent = "Full SQL"
        header.appendChild (cService)
        header.appendChild (cTime)
        header.appendChild (cUser)
        header.appendChild (cVersion)
        header.appendChild (cQueryTime)
        header.appendChild (cTotalTime)
        header.appendChild (cRequestId) 
        header.appendChild (cLog) 
        tblResult.appendChild(header)


         allMessages.forEach(m => 
            {
             
                const logRow = document.createElement("tr");
                const x = m.message.split(";")
                x.shift()
                console.log(`id: ${i++}`)
                console.log(`\tAt: ${new Date(m.time)} (${m.time})`)
                console.log(`\tUser: ${m.user}`)
                console.log(`\tTotal Time: ${numberWithCommas(Math.round(m.elapsed*1000))} ms (Total time the cursor was opened)`)
                console.log(`\tQuery Time: ${numberWithCommas(m.totalExecutionElapsed)} ms (includes search + data access nextRow)`)
                console.log(`\tQuery:`)
                x.forEach(a => console.log(`\t${a}`))
                console.log(`\n`)
                
                const cService = document.createElement("th");
                cService.textContent = m.source.replace(".MapServer", "")

                const cTime = document.createElement("td");
                cTime.textContent =  new Date(m.time).toLocaleString()
 
                const cUser = document.createElement("td");
                cUser.textContent = m.user
                const cVersion = document.createElement("td");
                const idxVersion = m.message.indexOf("Version: ")
                if (idxVersion >=0) {
                    const idxNext = m.message.indexOf(";",idxVersion)
                    cVersion.textContent = m.message.substr( idxVersion + 9, idxNext - idxVersion - 9 )
                }
                const cQueryTime = document.createElement("td");
                cQueryTime.textContent = msToMinSecMs(m.totalExecutionElapsed )// numberWithCommas(m.totalExecutionElapsed)
                const cTotalTime = document.createElement("td");
                cTotalTime.textContent = msToMinSecMs(m.elapsed*1000) //numberWithCommas(Math.round(m.elapsed*1000))
                const cRequestId = document.createElement("td");
                cRequestId.textContent = m.requestID
             
                const cLog = document.createElement("td");
                const cLogText = document.createElement("input")
                cLogText.type = "text"
                cLogText.style = "width:800px"
                cLogText.value = m.message.substr( m.message.indexOf("SQL: ") + 5, m.message.length)
                cLogText.readOnly= true;
                cLog.appendChild(cLogText)
                //cLog.textContent = m.message.substr( m.message.indexOf("SQL: ") + 5, 50) + "..."
                cLog.fullLog = m.message;
                cLog.title = m.message + "\nClick to copy"
                //cLog.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.fullLog); e.target.selectionStart = 0; e.target.selectionEnd = e.target.value.length;
                    /* alert("Copied to clipboard") *///})
                logRow.appendChild (cService)
                logRow.appendChild (cTime)
                logRow.appendChild (cUser)
                logRow.appendChild (cVersion)
                logRow.appendChild (cQueryTime)
                logRow.appendChild (cTotalTime)
                logRow.appendChild (cRequestId) 
                logRow.appendChild (cLog) 
                tblResult.appendChild(logRow)
                
 
        })
  
        addCSV(allMessages)
   
}

 
function numberWithCommas(x) {
   // return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
   return x.toLocaleString()
}

    //init();

    const btnTraceLogs = document.getElementById("btnTraceLogs");
    btnTraceLogs.addEventListener("click", e => loadTraceLogs()) 
    btnTraceLogs.disabled = true

    const btnValidateLogs = document.getElementById("btnValidateLogs");
    btnValidateLogs.addEventListener("click", e => loadValidateLogs())
    btnValidateLogs.disabled = true

    const btnUpdateSubnetworkLogs = document.getElementById("btnUpdateSubnetworkLogs");
    btnUpdateSubnetworkLogs.addEventListener("click", e => loadUpdateSubnetworkLogs())
    btnUpdateSubnetworkLogs.disabled = true
    

    const btnDownloadLogs = document.getElementById("btnDownloadLogs");
    btnDownloadLogs.addEventListener("click", e => downloadLogs())
    btnDownloadLogs.disabled = true


    const btnReconcileLogs = document.getElementById("btnReconcileLogs");
    btnReconcileLogs.addEventListener("click", e => reconcileLogs())
    btnReconcileLogs.disabled = true

    const btnstopEditingLogs = document.getElementById("btnstopEditingLogs");
    btnstopEditingLogs.addEventListener("click", e => stopEditingLogs())
    btnstopEditingLogs.disabled = true
 


    const btnSQLLogs = document.getElementById("btnSQLLogs");
    btnSQLLogs.addEventListener("click", e => loadSQLLogs())
    btnSQLLogs.disabled = true

     
    const btnApplyEditsLogs = document.getElementById("btnApplyEditsLogs");
    btnApplyEditsLogs.addEventListener("click", e => loadApplyEditsLogs())
    btnApplyEditsLogs.disabled = true

     
    const btnQueryLogs = document.getElementById("btnQueryLogs");
    btnQueryLogs.addEventListener("click", e => loadQueryLogs())
    btnQueryLogs.disabled = true

    const btnAR = document.getElementById("btnAR");
    btnAR.addEventListener("click", e => loadAttributeRules())
    btnAR.disabled = true

   function filterMessages (allMessages) {
        const txtFilter = document.getElementById("txtFilter")
        const txtUser = document.getElementById("txtUser")
        const txtMethodName = document.getElementById("txtMethodName")
        const txtRequestId = document.getElementById("txtRequestId")

        //don't bother if no filters
        if (txtFilter.value == "" && txtUser.value == "" 
        && txtMethodName.value == "" && txtRequestId.value == "" ) return allMessages;

        //const filtered= allMessages.filter(m => m.message.toUpperCase().indexOf(txtFilter.value.toUpperCase()) > 0 && m.user.toUpperCase().indexOf(txtUser.value.toUpperCase()) > 0) 
        const filtered= allMessages.filter(m => {

            if (m.message.toUpperCase().indexOf(txtFilter.value.toUpperCase()) >= 0 
                && 
                m.user.toUpperCase().indexOf(txtUser.value.toUpperCase()) >= 0 
                && 
                m.methodName.toUpperCase().indexOf(txtMethodName.value.toUpperCase()) >= 0 
                && 
                m.requestID.toUpperCase().indexOf(txtRequestId.value.toUpperCase()) >= 0 
                )
            return true

            return false
        }) 
        return filtered
    }

    async function populateMessagesAsIs(allTheMessages) {
        
        //build table
        const tblResult = document.getElementById("tblResult");
        //clear
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
        let totalElapsed = 0;
        const header = document.createElement("tr");
        const cService = document.createElement("th");
        cService.textContent = "Source"
        const cTime = document.createElement("th");
        cTime.textContent = "Time"
        const cUser = document.createElement("th");
        cUser.textContent = "User"
        const cMethod = document.createElement("th");
        cMethod.textContent = "Method"
        const cRequestId = document.createElement("th");
        cRequestId.textContent = "RequestId"
        const cCode = document.createElement("th");
        cCode.textContent = "Code"
        const cLevel = document.createElement("th");
        cLevel.textContent = "Level"
        const cElapsedMS = document.createElement("th");
        cElapsedMS.textContent = "Elapsed"
        const cLog = document.createElement("th");
        cLog.textContent = "Full Log"
        header.appendChild (cService)
        header.appendChild (cTime)
        header.appendChild (cUser)
        header.appendChild (cMethod)
        header.appendChild (cRequestId)
        header.appendChild (cCode)
        header.appendChild (cLevel)

        header.appendChild (cElapsedMS)
        header.appendChild (cLog) 
        tblResult.appendChild(header)
        allTheMessages.forEach(m => {
            const logRow = document.createElement("tr");
            const cService = document.createElement("td");
            cService.textContent = m.source.replace(".MapServer", "")
            const cTime = document.createElement("td");
            cTime.textContent =  new Date(m.time).toLocaleString() 
            const cUser = document.createElement("td");
            cUser.textContent = m.user
            const cMethod = document.createElement("td");
            cMethod.textContent = m.methodName
            const cRequestId = document.createElement("td");
            cRequestId.textContent = m.requestID
            const cCode = document.createElement("td");
            cCode.textContent = m.code
            const cLevel = document.createElement("td");
            cLevel.textContent = m.type
            const cElapsedMS = document.createElement("td");
            cElapsedMS.textContent =msToMinSecMs(m.elapsed) 
            totalElapsed+=m.elapsed
            const cLog = document.createElement("td");
            cLog.textContent = m.message 
           // cLog.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.fullLog); alert("Copied to clipboard")})
            logRow.appendChild (cService)
            logRow.appendChild (cTime)
            logRow.appendChild (cUser)
            logRow.appendChild (cMethod)
            logRow.appendChild (cRequestId)
            logRow.appendChild (cCode)
            logRow.appendChild (cLevel)
            logRow.appendChild (cElapsedMS)
            logRow.appendChild (cLog) 
            tblResult.appendChild(logRow)
        } 
        
        )
        const logRow = document.createElement("tr");
        const cTotalElapsedMS = document.createElement("td");
        cTotalElapsedMS.colSpan = 9
        cTotalElapsedMS.textContent = `Total Elapsed ${msToMinSecMs(totalElapsed)}`
        logRow.appendChild(cTotalElapsedMS)
        tblResult.appendChild(logRow)

    }
    async function populateMessages(allTheMessages) {

        //sort messages
                
        const allMessages = filterMessages (allTheMessages).map(m => {
            const newMessage = Object.assign({}, m);
            delete newMessage.machine;
            delete newMessage.type;
            delete newMessage.code;
            //delete newMessage.requestID;
            delete newMessage.process;
            delete newMessage.thread;
            newMessage.elapsedms = parseInt (parseFloat(newMessage.elapsed) * 1000)
            newMessage.time = new Date(newMessage.time).toLocaleString()
            delete newMessage.elapsed
            return newMessage;
        })
        .sort( (m1,m2) => m2.elapsedms - m1.elapsedms)
        
        //build table
        const tblResult = document.getElementById("tblResult");
        //clear
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)

        const header = document.createElement("tr");
        const cService = document.createElement("th");
        cService.textContent = "Source"
        const cTime = document.createElement("th");
        cTime.textContent = "Time"
        const cUser = document.createElement("th");
        cUser.textContent = "User"
        const cMethod = document.createElement("th");
        cMethod.textContent = "Method"
        const cElapsedMS = document.createElement("th");
        cElapsedMS.textContent = "Elapsed"
        const cLog = document.createElement("th");
        cLog.textContent = "Full Log"
        header.appendChild (cService)
        header.appendChild (cTime)
        header.appendChild (cUser)
        header.appendChild (cMethod)
        header.appendChild (cElapsedMS)
        header.appendChild (cLog) 
        tblResult.appendChild(header)
        allMessages.forEach(m => {
            const logRow = document.createElement("tr");
            const cService = document.createElement("td");
            cService.textContent = m.source.replace(".MapServer", "")
            const cTime = document.createElement("td");
            cTime.textContent = m.time
            const cUser = document.createElement("td");
            cUser.textContent = m.user
            const cMethod = document.createElement("td");
            cMethod.textContent = m.methodName
            const cElapsedMS = document.createElement("td");
            cElapsedMS.textContent = msToMinSecMs(m.elapsedms)
            const cLog = document.createElement("td");
            cLog.textContent = "..."
            cLog.fullLog = m.message;
            cLog.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.fullLog); alert("Copied to clipboard")})
            logRow.appendChild (cService)
            logRow.appendChild (cTime)
            logRow.appendChild (cUser)
            logRow.appendChild (cMethod)
            logRow.appendChild (cElapsedMS)
            logRow.appendChild (cLog) 
            tblResult.appendChild(logRow)
        })
    }


    //paging works from newer message walking to the oldest message
    //start time must be less than end time 
    //you specify startTime, t10 and endtime t1
    //you get back messages from t10 to t5,
    //you then start start time at t5 and end time at t1
    //you then get messages from t5 to t3
    //you then set the start time at t3 and end time at t1 
    //finally you get all messages between t3 and t1 and hasmore false.
    async function adminLogQueryWithPaging(mins, theService, code, messageFilter, level, methodFilter = ""){
        let topLogCount = 2000;
        let stop = false;
        const prg = document.createTextNode("Loading.... 0%");
        const btn = document.createElement("button")
        btn.textContent = '🛑'
        btn.addEventListener("click", ()=> stop = true )
        //create a new admin object (user might not be admin we won't use it until the user call log )
        let adminLog = new AdminLog(token, portal.serverUrl)
        tblResult.appendChild(prg);
        tblResult.appendChild(btn)
        let startTime = Date.now()
        const txtStartTime = document.getElementById("txtStartTime")
        if (txtStartTime.value != "")
            startTime = new Date(txtStartTime.value).getTime()

        let endTime = startTime - mins*60*1000
        const txtEndTime = document.getElementById("txtEndTime")
        if (txtEndTime.value != "")
            endTime = new Date(txtEndTime.value).getTime()

        let services = []
        if (!theService.includes(".GPServer"))
            services = [theService + ".MapServer"] 
        else
            services =  [theService] 
        
        if (theService == "(All Services)")
            services = "*"
        let result= await adminLog.query(code, services, topLogCount, startTime ,endTime , level)
        let jsonRes = await result.json()
        let allMessages = [].concat(jsonRes.logMessages) 
        allMessages = allMessages.filter(m => m.message.indexOf(messageFilter) > -1 && m.methodName.indexOf(methodFilter) > -1)
     
        let oldStart = undefined;
        let newStartTime = undefined;
        while (jsonRes.hasMore && !stop)
        {  
            //start paging
            oldStart = newStartTime;
            newStartTime = jsonRes.endTime 
            //we keep getting the same starttime, time to move towards end..
             if (oldStart == newStartTime)
                 newStartTime-=1;
 
            prg.textContent = "Loading ... " + Math.round(100*parseFloat((( (startTime - endTime) -  (newStartTime - endTime) ) /((startTime - endTime)))*100),2)/100+ "%"
            logger.info(`Aggregating messages... total so far ${allMessages.length} entries but more left, pulling logs between ${new Date(newStartTime)} and ${new Date(endTime)} ${newStartTime}-${endTime}`)
            result= await adminLog.query(code, services, topLogCount, newStartTime, endTime, level)
            jsonRes = await result.json()
            
            allMessages = allMessages.concat(jsonRes.logMessages.filter(m => m.message.indexOf(messageFilter) > -1 && m.methodName.indexOf(methodFilter) > -1))
        }
        logger.info(`Completed aggregation total messages ${allMessages.length}`);

        return allMessages

    }


     

    </script>
</body>
</html>