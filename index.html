<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UN Logs</title>
</head>
<body>

    <table>
        <tr><td>Service</td>
            <td colspan =3 ><select id ='cmbService'>
                <option>(All Services)</option>
            </select>
            </td>
        </tr>
         
    <tr> 
        <td >Age</td>
        <td colspan =3><input type ='text' id = 'txtAge' value = '30' style="width:30px"> minutes</td>
    </tr>
    <tr colspan =4>
        <td><button id = 'btnTraceLogs'>Trace Logs</button></td>
        <td><button id = 'btnValidateLogs'>Validate Logs</button></td>
        <td><button id = 'btnUpdateSubnetworkLogs'>Update Subnetwork Logs</button></td>
        <td><button id = 'btnAR'>Attribute Rules Logs</button></td>
        <td><button id = 'btnSQLLogs'>SQL Logs</button></td>
        <td>Message<input id = 'txtFilter' type = 'text'></td>
        <td>User<input id = 'txtUser' type = 'text'></td>
    </tr>

    </table>

    <table id = 'tblResult' border =1 cellpadding = 4 cellspacing = 4 style="text-align:center">

    </table>
    <script type = 'module'>
        import { Portal } from "./portal.mjs"
        import { UtilityNetwork } from "./utilitynetwork.node.mjs"
        import { AdminLog } from "./adminlog.mjs"
        import  logger  from "./logger.mjs"
 
    
    const parameters = {
        "user": "unadmin",
        "password": "xxx",
        "portal": "https://utilitynetwork.esri.com/portal",
        "service": "RedTrolley_SQLServer",
        "referer": "https://utilitynetwork.esri.com/log"
    }
 

    let portal;
    let adminLog = null;
    let cmbService 
   let token;
    async function init() {
        
        cmbService = document.getElementById("cmbService")
    
        token = await getToken(parameters);
        const services = await portal.services()
        const featureServices = services.services.filter(s => s.type == "FeatureServer")
        featureServices.forEach(s=> {
            const o = document.createElement("option");
            o.text = s.name;
            cmbService.appendChild(o);
        })
    }


    async function getToken(parameters) {
        portal = new Portal(parameters.portal, parameters.user, parameters.password,300, parameters.server, parameters.referer)
        console.log("About to connect..")
        const token = await portal.connect()
        console.log(`Token generanted successfully.`)
        return token;
    }


    async function loadTraceLogs () {
  
        //build table
        const tblResult = document.getElementById("tblResult");
        //clear
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)


        parameters.service = cmbService.options[cmbService.selectedIndex].text
    
        let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes
 
        console.log(`Querying trace logs for ${parameters.service} for the last ${mins} minutes ...`)
            
         //page query the admin log
         let allMessages = await adminLogQueryWithPaging(mins, parameters.service, [102002], "------ Trace Parameters ----", "VERBOSE")
 
         await populateMessages(allMessages)
 
         
    }
 

    
    async function loadValidateLogs () {
        //build table
        const tblResult = document.getElementById("tblResult");
        //clear
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
 
    parameters.service = cmbService.options[cmbService.selectedIndex].text

        
  let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes

  console.log(`Querying validate logs for ${parameters.service} for the last ${mins} minutes ...`)
        
        //-1 && m.message.indexOf("The network is built.") > -1 && m.methodName == 'BuildEngineLog')
         //page query the admin log
         let allMessages = await adminLogQueryWithPaging(mins, parameters.service, [102003], "The network is built.", "VERBOSE")
 
   
        //validate logs missing elapsed populate it
        allMessages = allMessages.map( m => {
            try{
                
                //The network is built. 0.093 seconds (4.982 total) - 29 MB memory
    
            let re = /The network is built. [-+]?([0-9]*\.[0-9]+|[0-9]+) seconds \([-+]?([0-9]*\.[0-9]+|[0-9]+) total\)/;
            let res = re.exec(m.message)
            if (res && res.length  > 1)
                m.elapsed = res[2]
            
                return m;
            }
            catch(ex){
                return m;
            }
        })


   await populateMessages(allMessages)

   
}


async function loadUpdateSubnetworkLogs () {
        //build table
        const tblResult = document.getElementById("tblResult");
        //clear
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
 
        parameters.service = cmbService.options[cmbService.selectedIndex].text 
        
        
        let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes

        
        console.log(`Querying subnetwork logs for ${parameters.service} for the last ${mins} minutes ...`)
        let allMessages = await adminLogQueryWithPaging(mins, parameters.service, [102003], "---- Subnetwork Parameters ----", "VERBOSE")

        
        //update subnetwork missing elapsed populate it
        allMessages = allMessages.map( m => {
            try{
 
            let re = /Total \([-+]?([0-9]*\.[0-9]+|[0-9]+) seconds\)/;
            let res = re.exec(m.message)
            if (res && res.length  > 1)
                m.elapsed = res[1]

            re = /Total update subnetwork time \([-+]?([0-9]*\.[0-9]+|[0-9]+) seconds\)/;
            res = re.exec(m.message)
            if (res && res.length  > 1)
                m.elapsed = res[1]
            
            return m;
            }
            catch(ex){
                return m;
            }
        })
        await populateMessages(allMessages)

   
}



async function loadAttributeRules () {
    
        //build table
        const tblResult = document.getElementById("tblResult");
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
 
        let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes

        parameters.service = cmbService.options[cmbService.selectedIndex].text 
     
        let showMaxGuid = true
        let showMinGuid = false 
             
        logger.info(`Querying attribute rules logs for ${parameters.service} in the past ${mins} minutes...`)
        let allMessages = await adminLogQueryWithPaging(mins, parameters.service, [102003], "Attribute rule execution complete:", "DEBUG")

 
        const arMessages = filterMessages(allMessages)
            .filter(m => m.message.indexOf("Attribute rule execution complete:") > -1)
            .map (m =>  JSON.parse(m.message.replace("Attribute rule execution complete:", "")))
            .map( m => {
                m["Elapsed Time (ms)"] =  Math.round(m["Elapsed Time"]*1000000)/1000
               // m["Arcade Evaluation Time:"] = Math.round(m["Arcade Evaluation Time:"]*1000,6)
                //m.ArcadeTime = m["Arcade Evaluation Time:"]
                
                delete  m["Arcade Evaluation Time:"];
                delete  m["Elapsed Time"];
                //delete m ['GlobalID'];
                return m
            })
            .sort( (m1, m2) => m2["Elapsed Time (ms)"]- m1["Elapsed Time (ms)"])
            .reduce( ( prev, cur ) => {
                if (prev [cur["Rule name"]] === undefined)
                   { 
                       prev [cur["Rule name"]] =  {
                           "totalTime": 0,
                           "occurrence": 0,
                           "minTime":  Number.MAX_SAFE_INTEGER,
                           "maxTime": -1,
                           "avgTime": 0,
                           "maxGuid": null,
                           "minGuid": null
                       };
                     }
                
                     prev [cur["Rule name"]].totalTime = prev [cur["Rule name"]].totalTime + cur["Elapsed Time (ms)"]
                      
                     if (cur["Elapsed Time (ms)"] < prev [cur["Rule name"]].minTime ) {
                        prev [cur["Rule name"]].minTime = cur["Elapsed Time (ms)"];
                        prev [cur["Rule name"]].minGuid = cur["GlobalID"];
                     }

                    if (cur["Elapsed Time (ms)"] > prev [cur["Rule name"]].maxTime ){
                        prev [cur["Rule name"]].maxTime = cur["Elapsed Time (ms)"];
                        prev [cur["Rule name"]].maxGuid = cur["GlobalID"];
                    }
                     
                    prev [cur["Rule name"]].occurrence++
                     
                    prev [cur["Rule name"]].avgTime = prev [cur["Rule name"]].totalTime / prev [cur["Rule name"]].occurrence

                return prev
            }, {})

        const rules = Object.keys(arMessages)
        .map(a => {
                const rule = {}
                rule["Attribute Rule"] = a;
                rule["Total Cost (ms)"] = parseFloat(arMessages[a].totalTime.toFixed(2))
                if (!showMinGuid && !showMaxGuid) rule["Average Cost (ms)"] = parseFloat(arMessages[a].avgTime.toFixed(2))
                rule["Max execution time (ms)"] = parseFloat(arMessages[a].maxTime.toFixed(2))
                if (showMaxGuid) rule["Max GUID"] = arMessages[a].maxGuid
                rule["Min execution time (ms)"] = parseFloat(arMessages[a].minTime.toFixed(2))
                if (showMinGuid) rule["Min GUID"] = arMessages[a].minGuid
                if (!showMinGuid && !showMaxGuid) rule["Occurrence"] = arMessages[a].occurrence;
                return rule;
        })
        .sort( (m1, m2) => m2["Total Cost (ms)"] -m1["Total Cost (ms)"])
        console.table(rules)

        /*
        Attribute Rule                        
        │ Total Cost (ms) 
        │ Max execution time (ms) 
        │ Max GUID 
        │ Min execution time (m

        */
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)

        const header = document.createElement("tr");
        const cAttributeRule = document.createElement("th");
        cAttributeRule.textContent = "Attribute Rule"
      
        const cTotalCost = document.createElement("th");
        cTotalCost.textContent = "Total Cost (ms)"
      
        const cMaxExecutionTime = document.createElement("th");
        cMaxExecutionTime.textContent = "Max execution time (ms)"

        const cMaxGuid = document.createElement("th");
        cMaxGuid.textContent = "Max GUID"

        const cMinExecutionTime = document.createElement("th");
        cMinExecutionTime.textContent = "Min execution time (ms)"

 
        header.appendChild (cAttributeRule)
        header.appendChild (cTotalCost)
        header.appendChild (cMaxExecutionTime)
        header.appendChild (cMaxGuid)
        header.appendChild (cMinExecutionTime)
    
        tblResult.appendChild(header)


        rules.forEach(rule => 
            {
             
                const logRow = document.createElement("tr");
                const cAttributeRule = document.createElement("td");
                cAttributeRule.textContent = rule["Attribute Rule"]
            
                const cTotalCost = document.createElement("td");
                cTotalCost.textContent = rule["Total Cost (ms)"]
            
                const cMaxExecutionTime = document.createElement("td");
                cMaxExecutionTime.textContent = rule["Max execution time (ms)"]

                const cMaxGuid = document.createElement("td");
                cMaxGuid.textContent = rule["Max GUID"] 

                const cMinExecutionTime = document.createElement("td");
                cMinExecutionTime.textContent =  rule["Min execution time (ms)"]
                
                logRow.appendChild (cAttributeRule)
                logRow.appendChild (cTotalCost)
                logRow.appendChild (cMaxExecutionTime)
                logRow.appendChild (cMaxGuid)
                logRow.appendChild (cMinExecutionTime)
                tblResult.appendChild(logRow)
                
 
        })


        const totalARExecution = rules.reduce( (prev, cur) =>  prev + cur["Total Cost (ms)"], 0)
        console.log(`Total time spend executing attribute rules (${Math.round(totalARExecution)} ms) (${Math.round(totalARExecution/1000)} s) (${Math.round(totalARExecution/(1000*60))} m)`)
         


}
async function loadSQLLogs () {

//build table
const tblResult = document.getElementById("tblResult");
//clear
while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)
 

  parameters.service = cmbService.options[cmbService.selectedIndex].text
   
  
  let mins = document.getElementById("txtAge").value  //query logs for the last 30 minutes

  
    console.log(`Querying cursor sql logs for ${parameters.service} for the last ${mins} minutes ...`)

        //startTime is the most recent
        //endTime is the oldest

        

    /*
     const topLogCount = 100;
        const startTime = Date.now()
        const endTime = Date.now() - mins*60*1000
        let services = [theService + ".MapServer"] 
        if (theService == "(All Services)")
            services = "*"
        let result= await adminLog.query([code], services, topLogCount, startTime ,endTime , "DEBUG")
        let jsonRes = await result.json()
        let allMessages = [].concat(jsonRes.logMessages) 
        allMessages = allMessages.filter(m => m.message.indexOf("EndCursor;") > -1)
        while (jsonRes.hasMore)
        {  
            //start paging
            logger.info(`Aggregating messages... total so far ${allMessages.length} entries but more left, pulling logs between ${new Date(jsonRes.endTime)} and ${new Date(endTime)}`)
            result= await adminLog.query([102023], services, pageSize, jsonRes.endTime, endTime, "DEBUG")
            jsonRes = await result.json()
  
            allMessages = allMessages.concat(jsonRes.logMessages.filter(m => m.message.indexOf("EndCursor;") > -1))
        }
        */

     //page query the admin log
      let allMessages = await adminLogQueryWithPaging(mins, parameters.service, [102023], "EndCursor;", "DEBUG")


      console.log ("Filtering messages...")
      
      allMessages = filterMessages(allMessages)
            .map( m=> {
                m.dataAccessElapsed = parseFloat(m.message.split(";")[1].split(" ")[1])
                m.executeQueryElapsed = parseFloat(m.message.split(";")[2].split(" ")[1])
                m.totalExecutionElapsed = m.dataAccessElapsed +  m.executeQueryElapsed 
                m.elapsed = parseFloat(m.elapsed); return m;

            })
            .sort( (m1,m2) => m2.totalExecutionElapsed - m1.totalExecutionElapsed)
            .slice(0, 100) ;//first 100
    
     
        console.log("-----Top 10 SQL----")
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)

        let i =0;
        
        const header = document.createElement("tr");
        const cService = document.createElement("th");
        cService.textContent = "Source"
        const cTime = document.createElement("th");
        cTime.textContent = "Time"
        const cUser = document.createElement("th");
        cUser.textContent = "User"
        const cVersion = document.createElement("th");
        cVersion.textContent = "Version"
        const cQueryTime = document.createElement("th");
        cQueryTime.textContent = "Query Time (ms)"
        cQueryTime.title  = "includes search + data access nextRow"
        const cTotalTime = document.createElement("th");
        cTotalTime.title  = "Total time the cursor was opened"
        cTotalTime.textContent = "Total Time (ms)"
        const cLog = document.createElement("th");
        cLog.textContent = "Full SQL"
        header.appendChild (cService)
        header.appendChild (cTime)
        header.appendChild (cUser)
        header.appendChild (cVersion)
        header.appendChild (cQueryTime)
        header.appendChild (cTotalTime)
        header.appendChild (cLog) 
        tblResult.appendChild(header)


        allMessages= allMessages.forEach(m => 
            {
             
                const logRow = document.createElement("tr");
                const x = m.message.split(";")
                x.shift()
                console.log(`id: ${i++}`)
                console.log(`\tAt: ${new Date(m.time)} (${m.time})`)
                console.log(`\tUser: ${m.user}`)
                console.log(`\tTotal Time: ${numberWithCommas(Math.round(m.elapsed*1000))} ms (Total time the cursor was opened)`)
                console.log(`\tQuery Time: ${numberWithCommas(m.totalExecutionElapsed)} ms (includes search + data access nextRow)`)
                console.log(`\tQuery:`)
                x.forEach(a => console.log(`\t${a}`))
                console.log(`\n`)
                
                const cService = document.createElement("th");
                cService.textContent = m.source.replace(".MapServer", "")

                const cTime = document.createElement("td");
                cTime.textContent =  new Date(m.time).toLocaleString()
 
                const cUser = document.createElement("td");
                cUser.textContent = m.user
                const cVersion = document.createElement("td");
                const idxVersion = m.message.indexOf("Version: ")
                if (idxVersion >=0) {
                    const idxNext = m.message.indexOf(";",idxVersion)
                    cVersion.textContent = m.message.substr( idxVersion + 9, idxNext - idxVersion - 9 )
                }
                const cQueryTime = document.createElement("td");
                cQueryTime.textContent = numberWithCommas(m.totalExecutionElapsed)
                const cTotalTime = document.createElement("td");
                cTotalTime.textContent = numberWithCommas(Math.round(m.elapsed*1000))
                const cLog = document.createElement("td");
                const cLogText = document.createElement("input")
                cLogText.type = "text"
                cLogText.style = "width:500px"
                cLogText.value = m.message.substr( m.message.indexOf("SQL: ") + 5, m.message.length)
                cLogText.readOnly= true;
                cLog.appendChild(cLogText)
                //cLog.textContent = m.message.substr( m.message.indexOf("SQL: ") + 5, 50) + "..."
                cLog.fullLog = m.message;
                cLog.title = m.message + "\nClick to copy"
                cLog.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.fullLog); e.target.selectionStart = 0; e.target.selectionEnd = e.target.value.length;
                    /* alert("Copied to clipboard") */})
                logRow.appendChild (cService)
                logRow.appendChild (cTime)
                logRow.appendChild (cUser)
                logRow.appendChild (cVersion)
                logRow.appendChild (cQueryTime)
                logRow.appendChild (cTotalTime)
                logRow.appendChild (cLog) 
                tblResult.appendChild(logRow)
                
 
        })
 
        
       
    



   //await populateMessages(allMessages)

   
}

 
function numberWithCommas(x) {
   // return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
   return x.toLocaleString()
}

    init();

    const btnTraceLogs = document.getElementById("btnTraceLogs");
    btnTraceLogs.addEventListener("click", e => loadTraceLogs()) 

    const btnValidateLogs = document.getElementById("btnValidateLogs");
    btnValidateLogs.addEventListener("click", e => loadValidateLogs())

    const btnUpdateSubnetworkLogs = document.getElementById("btnUpdateSubnetworkLogs");
    btnUpdateSubnetworkLogs.addEventListener("click", e => loadUpdateSubnetworkLogs())
 
    const btnSQLLogs = document.getElementById("btnSQLLogs");
    btnSQLLogs.addEventListener("click", e => loadSQLLogs())
 
    const btnAR = document.getElementById("btnAR");
    btnAR.addEventListener("click", e => loadAttributeRules())
 

   function filterMessages (allMessages) {
        const txtFilter = document.getElementById("txtFilter")
        const txtUser = document.getElementById("txtUser")
        if (txtFilter.value == "" && txtUser.value == "") return allMessages;
        //const filtered= allMessages.filter(m => m.message.toUpperCase().indexOf(txtFilter.value.toUpperCase()) > 0 && m.user.toUpperCase().indexOf(txtUser.value.toUpperCase()) > 0) 
        const filtered= allMessages.filter(m => {

            if (m.message.toUpperCase().indexOf(txtFilter.value.toUpperCase()) >= 0 
                    && 
                m.user.toUpperCase().indexOf(txtUser.value.toUpperCase()) >= 0)
            return true

            return false
        }) 
        return filtered
    }

    async function populateMessages(allTheMessages) {

        //sort messages
                
        const allMessages = filterMessages (allTheMessages).map(m => {
            const newMessage = Object.assign({}, m);
            delete newMessage.machine;
            delete newMessage.type;
            delete newMessage.code;
            delete newMessage.requestID;
            delete newMessage.process;
            delete newMessage.thread;
            newMessage.elapsedms = parseInt (parseFloat(newMessage.elapsed) * 1000)
            newMessage.time = new Date(newMessage.time).toLocaleString()
            delete newMessage.elapsed
            return newMessage;
        })
        .sort( (m1,m2) => m2.elapsedms - m1.elapsedms)
        
        //build table
        const tblResult = document.getElementById("tblResult");
        //clear
        while(tblResult.firstChild) tblResult.removeChild(tblResult.firstChild)

        const header = document.createElement("tr");
        const cService = document.createElement("th");
        cService.textContent = "Source"
        const cTime = document.createElement("th");
        cTime.textContent = "Time"
        const cUser = document.createElement("th");
        cUser.textContent = "User"
        const cMethod = document.createElement("th");
        cMethod.textContent = "Method"
        const cElapsedMS = document.createElement("th");
        cElapsedMS.textContent = "Elapsed (ms)"
        const cLog = document.createElement("th");
        cLog.textContent = "Full Log"
        header.appendChild (cService)
        header.appendChild (cTime)
        header.appendChild (cUser)
        header.appendChild (cMethod)
        header.appendChild (cElapsedMS)
        header.appendChild (cLog) 
        tblResult.appendChild(header)
        allMessages.forEach(m => {
            const logRow = document.createElement("tr");
            const cService = document.createElement("td");
            cService.textContent = m.source.replace(".MapServer", "")
            const cTime = document.createElement("td");
            cTime.textContent = m.time
            const cUser = document.createElement("td");
            cUser.textContent = m.user
            const cMethod = document.createElement("td");
            cMethod.textContent = m.methodName
            const cElapsedMS = document.createElement("td");
            cElapsedMS.textContent = m.elapsedms
            const cLog = document.createElement("td");
            cLog.textContent = "..."
            cLog.fullLog = m.message;
            cLog.addEventListener("click", e=> {navigator.clipboard.writeText(e.target.fullLog); alert("Copied to clipboard")})
            logRow.appendChild (cService)
            logRow.appendChild (cTime)
            logRow.appendChild (cUser)
            logRow.appendChild (cMethod)
            logRow.appendChild (cElapsedMS)
            logRow.appendChild (cLog) 
            tblResult.appendChild(logRow)
        })
    }


    async function adminLogQueryWithPaging(mins, theService, code, filter, level){
        const topLogCount = 1000;
        let stop = false;
        const prg = document.createTextNode("Loading.... 0%");
        const btn = document.createElement("button")
        btn.textContent = '🛑'
        btn.addEventListener("click", ()=> stop = true )
        //create a new admin object (user might not be admin we won't use it until the user call log )
        let adminLog = new AdminLog(token, portal.serverUrl)
        tblResult.appendChild(prg);
        tblResult.appendChild(btn)
        const startTime = Date.now()
        const endTime = Date.now() - mins*60*1000
        let services = [theService + ".MapServer"] 
        if (theService == "(All Services)")
            services = "*"
        let result= await adminLog.query(code, services, topLogCount, startTime ,endTime , level)
        let jsonRes = await result.json()
        let allMessages = [].concat(jsonRes.logMessages) 
        allMessages = allMessages.filter(m => m.message.indexOf(filter) > -1)
        while (jsonRes.hasMore && !stop)
        {  
            //start paging
            prg.textContent = "Loading ... " + parseInt((( (startTime - endTime) -  (jsonRes.endTime - endTime) ) /((startTime - endTime)))*100) + "%"
            logger.info(`Aggregating messages... total so far ${allMessages.length} entries but more left, pulling logs between ${new Date(jsonRes.endTime)} and ${new Date(endTime)}`)
            result= await adminLog.query(code, services, topLogCount, jsonRes.endTime, endTime, level)
            jsonRes = await result.json()
  
            allMessages = allMessages.concat(jsonRes.logMessages.filter(m => m.message.indexOf(filter) > -1))
        }

        return allMessages

    }


    /*
     const topLogCount = 100;f
        const startTime = Date.now()
        const endTime = Date.now() - mins*60*1000
        let services = [theService + ".MapServer"] 
        if (theService == "(All Services)")
            services = "*"
        let result= await adminLog.query([code], services, topLogCount, startTime ,endTime , "DEBUG")
        let jsonRes = await result.json()
        let allMessages = [].concat(jsonRes.logMessages) 
        allMessages = allMessages.filter(m => m.message.indexOf("EndCursor;") > -1)
        while (jsonRes.hasMore)
        {  
            //start paging
            logger.info(`Aggregating messages... total so far ${allMessages.length} entries but more left, pulling logs between ${new Date(jsonRes.endTime)} and ${new Date(endTime)}`)
            result= await adminLog.query([102023], services, pageSize, jsonRes.endTime, endTime, "DEBUG")
            jsonRes = await result.json()
  
            allMessages = allMessages.concat(jsonRes.logMessages.filter(m => m.message.indexOf("EndCursor;") > -1))
        }
        */
    </script>
</body>
</html>